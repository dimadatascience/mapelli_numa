---
title: "Introduction to the analysis of bulk RNAseq in NuMa Project"
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    theme: united
    code_folding: hide
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Gianluca Alessio Mariani"

params:
  sample_info_file: "./data/samples_info.tsv"
  dds_file: "./data/deseq2.dds.RData"
  main_description: "./data/main_description.txt" 
  min_sample: 2
  logfc: log2(2)
  qvalue: 0.05
---

```{r}
knitr::opts_chunk$set(echo       = FALSE,
                      message    = FALSE,
                      warning    = FALSE,
                      cache      = FALSE,
                      autodep    = TRUE,
                      fig.align  = 'center',
                      fig.width  = 10,
                      fig.height = 8)
```

```{r parameters}
min_sample = params$min_sample
logfc=params$logfc
qvalue=params$qvalue
rdata_file=params$dds_file
```

## Introduction

#### TEMPORARY DRAFT

```{r introduction, results="asis", echo=FALSE}
text_lines <- readLines(params$main_description)
cat(text_lines, sep = "\n")
```


### Overview of the analysis steps

1) Quality control of raw data with [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
2) Adapter and quality trimming with [Trim Galore!](https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/)
3) Read alignment with [STAR](https://github.com/alexdobin/STAR).
4) Estimation of transcript and gene expression with [Salmon](https://combine-lab.github.io/salmon/).
5) Differential gene expression analysis with [DESeq2](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) (v1.49.1)
6) Gene set enrichment analysis with [ClusterProfiler](https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html) (v4.17.0)

The steps from 1 to 4 have been performed using [nf-core/rnaseq](https://nf-co.re/rnaseq) v3.14.0.
This report includes analysis from step 5 and 6

```{r libraries}
source("src/__utils_rna_seq_functions.R")

# LIBRARY
if (!require("DT")) install.packages('DT')
if (!require("git2r")) install.packages("git2r")
if (!require("reshape2")) install.packages("reshape2")

library("DESeq2")
library(rtracklayer)
library(ComplexHeatmap)
library(RColorBrewer)
library(gplots) 
library(ggplot2)
library("DT")
library(reshape)
library(plotly)
library(clusterProfiler)
library(dplyr)
library(WGCNA)
library(gridExtra)
library("git2r")
library(limma)
library(tibble)
library(CorLevelPlot)
library(ReactomePA)
```

## Samples Datatable

Below we present the table containing all the samples analyzed in this report.  

Each sample is described by:

  - sample: sample name defined a priori in the previous step of RNA seq analysis

  - sample_description: a descriptive version of the sample name to improve clarity in the presentation of data

  - batch: the experimental batch of each sample

  - condition: the treatment condition (e.g. control, knockdown, treated, etc...)

  - condition_description: a descriptive version of the condition to improve clarity in the presentation of data

```{r load_samples, results="asis"}

# Leggi i dati
sample_info <- read.table(params$sample_info_file, header = TRUE, sep = "\t")
rownames(sample_info) <- sample_info$sample

# Converti tutte le colonne a fattori
sample_info[] <- lapply(sample_info, as.factor)

clean_sample_info <- sample_info[, !(colnames(sample_info) %in% c("sample_type", "sample_group"))]

datatable(
   clean_sample_info,
   extensions = 'Buttons',   
   options = list(     
        dom = 'Blfrtip',     
        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),     
        lengthMenu = list(c(10, 25, 50, -1),                       
        c(10, 25, 50, "All"))   
        ),   
    rownames = FALSE )
```

```{r additional_data, results="asis"}

# 1. Rileva batch effect
n_batches <- length(unique(sample_info$batch))
batch_effect <- n_batches > 1

# 2. Identifica i campioni tecnici di controllo (tc)
# Si assume che 'sample_type' contenga livelli come "tc", "t", "c", "e"
technical_controls <- subset(sample_info, sample_type %in% c("tc", "t"))
```

```{r batch_effect_text, results="asis", echo=FALSE}
if (nrow(technical_controls) == 0 && batch_effect) {
  warning("⚠️ Batch effect detected but no technical control specified (sample_type == 'tc' or 't')")
}

# Testo base
batch_text <- paste0(
  "### Batch Effect Correction\n\n",
  "Differential expression analysis is performed using a custom function, which accounts for batch effect. ",
  "A batch effect occurs when in an experiment non-biological factors, like laboratory conditions or instruments used, cause changes in the data produced by the experiment.")
cat(batch_text)

# Aggiungi frase in base a batch_effect
if (batch_effect) {
  cat("<br><br>In this analysis the samples have been collected in", n_batches, "different batches, so batch correction will be applied.")
} else {
  cat("<br><br>In this analysis the samples have been collected in only", n_batches, "batch, so no batch correction will be applied.")
}
```

```{r sample_grouping, results="asis"}
# 3. Crea lista dei gruppi sperimentali per DGE
# Per ogni sample_group, identifica exp vs control
deseq_groups <- list()

for (grp in levels(sample_info$sample_group)) {
  group_samples <- subset(sample_info, sample_group == grp)
  
  # Separazione campioni
  exp_samples <- subset(group_samples, sample_type == "e")
  ctrl_samples <- subset(group_samples, sample_type %in% c("c", "tc"))
  
  if (nrow(exp_samples) > 0 && nrow(ctrl_samples) > 0) {
    # Prendi i nomi campioni
    exp_sample_names <- rownames(exp_samples)
    ctrl_sample_names <- rownames(ctrl_samples)
    
    # Prendi le condizioni (testo descrizione) uniche per experimental e control
    exp_conditions <- unique(exp_samples$condition_description)
    ctrl_conditions <- unique(ctrl_samples$condition_description)
    
    # Unisci le condizioni in una stringa separata da virgole (se più di una)
    exp_conditions_text <- paste(exp_conditions, collapse = ", ")
    ctrl_conditions_text <- paste(ctrl_conditions, collapse = ", ")
    
    deseq_groups[[as.character(grp)]] <- list(
      group_id = grp,
      experimental = exp_sample_names,
      control = ctrl_sample_names,
      exp_condition = exp_conditions_text,
      ctrl_condition = ctrl_conditions_text
    )
  } else {
    warning(paste("The group", grp, "does not have a valid comparison (exp + ctrl)"))
  }
}
```


## Comparisons definition

The comparisons included in the report are listed below. Each comparison group includes two subsets of samples: an 'treatment' group and a control group. Differential gene expression analysis is conducted by comparing the 'treatment' samples to the control samples within each group.

```{r sample_grouping_text, results="asis", echo=FALSE}
text_deseq_groups <- ""

if (length(deseq_groups) > 0) {
  
  for (grp_name in names(deseq_groups)) {
    grp <- deseq_groups[[grp_name]]
    
    # Costruisci la descrizione confronto
    comparison_text <- paste0("(", grp$exp_condition, " vs ", grp$ctrl_condition, ")")
    
    text_deseq_groups <- paste0(text_deseq_groups,
      "\n\n",
      "➤ Group: ", grp_name, ", ", comparison_text, "\n",
      "\n\t- **Experimental samples** (", grp$exp_condition, ", e):\n",
      paste0("\t\t", grp$experimental, collapse = "\n"), "\n",
      "\n\t- **Control Samples** (", grp$ctrl_condition, ", c/tc):\n",
      paste0("\t\t", grp$control, collapse = "\n"), "\n"
    )
  }
  
} else {
  text_deseq_groups <- "⚠️ No valid group defined for DGE analysis.\n"
}
```

```{r show_deseq_groups, results = "asis", echo = FALSE}
text_html <- gsub("\n", "<br>", text_deseq_groups)
text_html <- gsub("\t", "&nbsp;&nbsp;&nbsp;&nbsp;", text_html)
cat(text_html)
```

```{r load_data_deseq, results="asis"}
# Load DESeq2 object containing raw count data
load(rdata_file)

# Pulisci i nomi campioni in sample_info
sample_info$sample <- make.names(sample_info$sample)
rownames(sample_info) <- sample_info$sample

# Trova i campioni comuni
common_samples <- intersect(colnames(dds), sample_info$sample)

# Filtra dds e sample_info per tenere solo i campioni comuni
dds <- dds[, common_samples]
sample_info <- sample_info[common_samples, ]

# Controlla che i nomi siano allineati
stopifnot(all(colnames(dds) == rownames(sample_info)))

colData(dds)$sample <- sample_info$sample
colData(dds)$sample_description <- sample_info$sample_description
colData(dds)$condition <- sample_info$condition
colData(dds)$condition_description <- sample_info$condition_description

# Supponiamo di avere il dataframe sample_info con queste colonne
design_vars <- c("batch", "condition")  # variabili candidate per il design
# Controlla quali variabili sono costanti
constant_vars <- check_constant_vars(sample_info, design_vars)
if (length(constant_vars) > 0) {
  message("Variabili costanti trovate e rimosse dal design: ", paste(constant_vars, collapse = ", "))
}
# Variabili valide da usare nel design (non costanti)
valid_vars <- setdiff(design_vars, constant_vars)
if (length(valid_vars) == 0) {
  stop("Nessuna variabile valida per il design. Controlla i dati.")
}
# Costruisci la formula del design in modo dinamico
design_formula <- as.formula(
  paste("~", paste(valid_vars, collapse = " + "))
)
```

## PCA Analysis

For the PCA (principal component analysis) and correlation analyses, gene expression data were normalized using the variance stabilizing transformation (VST) method implemented in DESeq2.

Below, we present the PPCA performed on the complete set of samples. PCA was used to explore global variance in gene expression profiles across all samples.

The primary objectives of this analysis are to:

- Assess sample quality

- Determine whether samples cluster according to experimental conditions, suggesting biologically meaningful variation

- Identify potential outliers

- Detect batch effects or other sources of unwanted variation

By reducing the high-dimensional gene expression data into a few principal components, PCA provides a visual summary of the dataset’s structure.

```{r PCA_all, results="asis"}

counts <- assay(dds)
min_reads <- round(ncol(counts) / 2)

out <- preprocessing_PCA(counts, 
    min_reads, 
    sample_info, 
    normalization = "vst",
    min_sample = 5, 
    design_formula = design_formula,
    )

rld <- out[["rld"]]

colData(rld)$sample <- sample_info$sample
colData(rld)$sample_description <- sample_info$sample_description
colData(rld)$condition <- sample_info$condition
colData(rld)$condition_description <- sample_info$condition_description

sample_names <- colnames(rld)  # nomi attuali delle colonne
alt_labels <- colData(rld)$sample_description  # nomi alternativi (sample_description)
name_map <- setNames(as.character(alt_labels), sample_names)

mypcaAnalysis(
  title_1vs2 = "PCA analysis all samples", 
  rld = rld,
  intgroup = "condition_description"
)

```

__INTEPRETATION MISSING__

## Correlation analysis

The Spearman correlation heatmap provides a global view of the similarity between gene expression profiles across all samples.
We calculated the pairwise Spearman correlation coefficients between samples and visualized them in a heatmap.
Rows and columns are hierarchically clustered based on these correlations to reveal patterns of similarity and potential groupings among samples.

```{r heatmap_correlation, results="asis"}
# Calcola la matrice di correlazione tra campioni (Pearson)
cor_matrix <- cor(assay(rld), method = "spearman")
colnames(cor_matrix) <- name_map[colnames(cor_matrix)]
rownames(cor_matrix) <- name_map[rownames(cor_matrix)]

# Matrice delle distanze per il clustering (1 - correlazione)
clustering_dist <- as.dist(1 - cor_matrix)

# Annota i gruppi
annotation_df <- as.data.frame(colData(dds)[, "condition_description", drop = FALSE])
colnames(annotation_df) <- "Condition"
rownames(annotation_df) <- name_map[rownames(annotation_df)]

# Estrai le condizioni uniche da colData
conditions <- unique(as.character(colData(dds)$condition_description))
n_conditions <- length(conditions)

# Palette automatica (Set2 supporta fino a 8 colori distinti e leggibili)
palette_colors <- brewer.pal(min(n_conditions, 8), "Set2")

# Se ci sono più condizioni della palette, crea una palette più grande
if (n_conditions > length(palette_colors)) {
  palette_colors <- colorRampPalette(brewer.pal(8, "Set2"))(n_conditions)
}

# Mappa condizione -> colore
annotation_colors <- list(
  Condition = setNames(palette_colors, conditions)
)
```

### **Spearman Correlation: General Interpretation**

####  **High Correlation Values** (e.g., > 0.98)  
*Between replicates of the same condition:*  

  - A very good quality signal  

  - Indicates that replicates behave consistently  

  - Suggests well-defined and reproducible biological conditions  

*Between different conditions:*  

  - May indicate minor transcriptional differences  

  - Or poor separation due to contamination or mislabeling

#### **Lower Correlation Values** (e.g., < 0.95)  
*Between replicates of the same condition:* 

  - May suggest technical or biological issues:  

    - Library prep/sequencing errors  

    - Sample mix-up or mislabeling  

    - Biological heterogeneity  

In some cases, biological replicates may exhibit a certain degree of variability that cannot be entirely avoided. 
This is particularly true when samples are obtained from different individuals, such as patient-derived samples, even when all other experimental conditions are carefully controlled.

Therefore, lower correlation values between replicates should not be interpreted in a standardized way, but rather evaluated in the specific biological and experimental context of the study.

*Between different conditions:*  

  - Expected when conditions are biologically distinct  

  - If correlations are too similar to replicates, it may suggest:  

    - Weak treatment effects  

    - Few genes affected by the condition  


### Spearman Correlation Heatmap

Below we present the heatmap associated spearman correlation. __INTERPRETATION__ 

```{r heatmap_correlation_plot, fig.width=8, fig.height=6}
# Heatmap direttamente sulla matrice di correlazione
pheatmap(
  cor_matrix,
  clustering_distance_rows = clustering_dist,
  clustering_distance_cols = clustering_dist,
  annotation_col = annotation_df,
  annotation_colors = annotation_colors,
  main = "Sample-to-sample correlation (Spearman)",
  display_numbers = TRUE,
  number_format = "%.2f",
  fontsize_number = 7,     # aumenta il font dei numeri
  cellheight = 14,          # altezza delle celle
  cellwidth = 14            # larghezza delle celle
)
```

## Library Sizes

A bar plot displaying total read counts per sample is shown below

__INTERPRETATION__

```{r counts_dds, results="asis", fig.width=8}
# Create a data frame for plotting
lib_sizes <- data.frame(
  sample_description = colData(dds)$sample_description,
  total_counts = colSums(counts(dds))
)

# Plot
ggplot(lib_sizes, aes(x = sample_description, y = total_counts)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme_minimal() +
  labs(title = "",
       x = "Sample",
       y = "Total Counts") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Violin plot of VST-normalized counts

Below we present a violin plot of the VST-normalized read counts by sample.

A violin plot of VST-normalized counts provides an overview of the global distribution of gene expression values across samples after normalization.  This plot allows for the detection of potential outliers, technical biases, or inconsistencies in distribution across samples, which could affect downstream analyses. A consistent distribution of VST counts across samples suggests successful normalization and comparable expression profiles.

```{r violin_dds, results="asis", fig.width=8, fig.height=5}
# Estrai i dati rlog e riformattali
rld_matrix <- assay(rld)
df_long <- reshape2::melt(rld_matrix, varnames = c("gene", "sample"), value.name = "expression")

df_long$sample <- name_map[as.character(df_long$sample)]

# Crea violin plot
ggplot(df_long, aes(x = sample, y = expression)) +
  geom_violin(trim = FALSE, fill = "#8da0cb", color = "black") +
  geom_boxplot(width = 0.1, outlier.size = 0.5) +  # opzionale, overlay del boxplot
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1),  # rotazione etichette asse X
    axis.title.x = element_blank()
  ) +
  labs(
    y = "VST-normalized expression",
    title = ""
  )
```



